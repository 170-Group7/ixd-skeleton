(function (QUnit,sinon,videojs) {
'use strict';

QUnit = 'default' in QUnit ? QUnit['default'] : QUnit;
sinon = 'default' in sinon ? sinon['default'] : sinon;
videojs = 'default' in videojs ? videojs['default'] : videojs;

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var empty = {};


var empty$1 = (Object.freeze || Object)({
	'default': empty
});

var minDoc = ( empty$1 && empty ) || empty$1;

var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal :
    typeof window !== 'undefined' ? window : {};


var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

var document_1 = doccy;

var videojsSnapshot = createCommonjsModule(function (module) {
  // import videojs from 'video.js';
  // import {version as VERSION} from '../package.json';
  (function (root, factory) {
    if (typeof undefined === 'function' && undefined.amd) {
      // AMD. Register as an anonymous module.
      undefined(['video.js'], factory);
    } else if ('object' === 'object' && module.exports) {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory(videojs);
    } else {
      // Browser globals (root is window)
      root.returnExports = factory(root.videojs);
    }
  })(commonjsGlobal, function (videojs$$1) {
    'use strict';

    console.log('video-js-snapshot');
    // Default options for the plugin.
    var defaultOptions = {};
    // Cross-compatibility for Video.js 5 and 6.
    var registerPlugin = videojs$$1.registerPlugin || videojs$$1.plugin;

    // const dom = videojs.dom || videojs;
    var VjsComponent = videojs$$1.getComponent('Component');
    var VjsButton = videojs$$1.getComponent('Button');

    /**
     * Base class for recorder backends.
     * @class
     * @augments videojs.Component
     * @private
     */
    videojs$$1.SnapshoterBaseComponent = videojs$$1.extend(VjsComponent, {
      /**
       * The constructor function for the class.
       *
       * @private
       * @param {(videojs.Player|Object)} player - Video.js player instance.
       * @param {Object} options - Player options.
       */
      constructor: function constructor(player, options) {
        VjsComponent.call(this, player, options);
      },

      /**
       * Remove any temporary data and references to streams.
       * @private
       */
      dispose: function dispose() {}

    });

    /**
     * Take a snapshotof audio/video/images using the Video.js player.
     *
     * @class
     * @augments videojs.RecordBase
     */
    videojs$$1.SnapshoterComponent = videojs$$1.extend(videojs$$1.SnapshoterBaseComponent, {
      /**
       * The constructor function for the class.
       *
       * @param {(videojs.Player|Object)} player
       * @param {Object} options - Player options.
       */
      constructor: function constructor(player, options) {
        // run base component initializing with new options.
        VjsComponent.call(this, player, options);

        // setup plugin options
        this.loadOptions();

        // (re)set recorder state
        this.resetState();

        // wait until player ui is ready
        this.player().one('ready', this.setupUI.bind(this));
        var EngineClass = videojs$$1.ImageCaptureEngine;
        try {
          // connect stream to recording engine
          this.engine = new EngineClass(this.player());
        } catch (err) {
          throw new Error('Could not load ' + videojs$$1.ImageCaptureEngine + ' plugin');
        }
      },

      /**
       * Setup plugin options.
       */
      loadOptions: function loadOptions() {
        // record settings
      },

      /**
       * Player UI is ready.
       * @private
       */
      setupUI: function setupUI() {
        // insert custom controls on left-side of controlbar
        this.player().controlBar.addChild(this.player().cameraButton);
        this.player().controlBar.el().insertBefore(this.player().cameraButton.el(), this.player().controlBar.el().firstChild);

        // customize controls
        // XXX: below are customizations copied from videojs.wavesurfer that
        //      tweak the video.js UI...
        this.player().bigPlayButton.hide();

        if (this.player().options_.controls) {
          // videojs automatically hides the controls when no valid 'source'
          // element is included in the 'audio' tag. Don't. Ever again.
          this.player().controlBar.show();
          this.player().controlBar.el().style.display = 'flex';
        }
      },

      /**
       * Indicates whether the plugin is currently recording or not.
       *
       * @return {boolean} Plugin currently recording or not.
       */
      isSnapshoting: function isSnapshoting() {
        return this._snapshoting;
      },

      /**
       * Indicates whether the plugin is currently processing recorded data
       * or not.
       *
       * @return {boolean} Plugin processing or not.
       */
      isProcessing: function isProcessing() {
        return this._processing;
      },

      /**
       * Indicates whether the plugin is destroyed or not.
       *
       * @return {boolean} Plugin destroyed or not.
       */
      isDestroyed: function isDestroyed() {
        return this.player() && this.player().children() === null;
      },

      /**
       * Start recording.
       */
      start: function start() {
        if (!this.isProcessing()) {
          this._snapshoting = true;
          this._processing = true;

          // hide play control
          this.player().controlBar.playToggle.hide();

          // create snapshot
          this.createSnapshot();
        }
      },

      /**
       * Stop recording.
       */
      stop: function stop() {
        if (this.isProcessing()) {
          this._snapshoting = false;
          this._processing = false;
        }
        // show play control
        this.player().controlBar.playToggle.show();
      },

      /**
       * Destroy plugin and players and cleanup resources.
       */
      destroy: function destroy() {
        // stop recording and device
        this.stop();
        // dispose player
        this.player().dispose();

        this.resetState();
      },

      /**
       * Reset the plugin.
       */
      reset: function reset() {

        // stop recording and device
        this.stop();

        // reset options
        this.loadOptions();

        // reset recorder state
        this.resetState();
        // reset player
        this.player().reset();

        // reset UI
        this.player().snapshotCanvas.hide();
        this.player().cameraButton.hide();
      },

      /**
       * Reset the plugin recorder state.
       * @private
       */
      resetState: function resetState() {
        this._snapshoting = false;
        this._processing = false;
      },

      /**
       * Create and display snapshot image.
       * @private
       */
      createSnapshot: function createSnapshot() {
        var thiz = this;
        this.captureFrame().then(function (snapshotImageData) {

          thiz.player().trigger('snap', snapshotImageData);

          // stop recording
          thiz.stop();
        });
      },

      /**
       * Reset UI for retrying a snapshot image.
       * @private
       */
      retrySnapshot: function retrySnapshot() {
        this._processing = false;

        // retry: hide the snapshot
        this.player().snapshotCanvas.hide();
      },

      /**
       * Capture frame from camera and copy data to canvas.
       * @private
       */
      captureFrame: function captureFrame() {
        var thiz = this;
        var snapshotCanvas = this.player().snapshotCanvas.el().firstChild;

        // set the canvas size to the dimensions of the camera,
        // which also wipes the content of the canvas
        snapshotCanvas.width = this.player().videoWidth();
        snapshotCanvas.height = this.player().videoHeight();
        // var tech = thiz.player().tech().name();
        return new Promise(function (resolve, reject) {
          var snapshotImageData = thiz.engine.imageCaptureByIdAndCanvasDom(thiz.player().id(), snapshotCanvas);
          // notify others
          return resolve(snapshotImageData);
        });
      }

    });
    var CameraButton, SnapshotCanvasComponent;

    /**
     * Canvas for displaying snapshot image.
     * @private
     * @class
     * @augments videojs.Component
     */
    SnapshotCanvasComponent = videojs$$1.extend(VjsComponent);
    /**
     * Button to toggle between create and retry snapshot image.
     * @private
     * @class
     * @augments videojs.Button
     */
    CameraButton = videojs$$1.extend(VjsButton, {
      /** @constructor */
      constructor: function constructor(player, options) {
        VjsButton.call(this, player, options);

        this.on('click', this.onClick);
        this.on('tap', this.onClick);
      }
    });
    CameraButton.prototype.onClick = function (e) {
      // stop this event before it bubbles up
      e.stopImmediatePropagation();

      var snapshoter = this.player().snapshoter;

      if (!snapshoter.isProcessing()) {
        // create snapshot
        snapshoter.start();
      } else {
        // retry
        snapshoter.retrySnapshot();

        // reset camera button
        this.onStop();
      }
    };
    CameraButton.prototype.onStart = function () {
      // replace element class so it can change appearance
      this.removeClass('vjs-icon-photo-camera');
      this.addClass('vjs-icon-photo-retry');

      // update label
      this.el().firstChild.firstChild.innerHTML = this.localize('Retry');
    };
    CameraButton.prototype.onStop = function () {
      // replace element class so it can change appearance
      this.removeClass('vjs-icon-photo-retry');
      this.addClass('vjs-icon-photo-camera');

      // update label
      this.el().firstChild.firstChild.innerHTML = this.localize('Image');
    };

    /**
     * Create a custom button.
     * @private
     * @param {string} className - Class name for the new button.
     * @param {string} label - Label for the new button.
     * @param {string} iconName - Icon for the new button.
     */
    var createButton = function createButton(className, label, iconName) {
      var props = {
        className: 'vjs-' + className + '-button vjs-control vjs-icon-' + iconName,
        innerHTML: '<div class="vjs-control-content"><span class="vjs-control-text">' + label + '</span></div>'
      };
      var attrs = {
        role: 'button',
        'aria-live': 'polite', // let the screen reader user know that the text of the button may change
        tabIndex: 0
      };
      return VjsComponent.prototype.createEl('div', props, attrs);
    };

    /**
     * Create a custom button.
     * @private
     * @param {string} className - Class name for the new button.
     * @param {string} label - Label for the new button.
     * @param {string} iconName - Icon for the new button.
     */
    var createCanvas = function createCanvas(className) {
      var props = {
        className: 'vjs-' + className + '-canvas',
        innerHTML: '<canvas></canvas>'
      };
      return VjsComponent.prototype.createEl('div', props);
    };

    /**
     * Function to invoke when the player is ready.
     *
     * This is a great place for your plugin to initialize itself. When this
     * function is called, the player will have its DOM and child components
     * in place.
     *
     * @function onPlayerReady
     * @param    {Player} player
     *           A Video.js player object.
     *
     * @param    {Object} [options={}]
     *           A plain object containing options for the plugin.
     */
    var onPlayerReady = function onPlayerReady(player, options) {
      player.addClass('vjs-snapshot');
    };

    /**
     * A video.js plugin.
     *
     * In the plugin function, the value of `this` is a video.js `Player`
     * instance. You cannot rely on the player being in a "ready" state here,
     * depending on how the plugin is invoked. This may or may not be important
     * to you; if not, remove the wait for "ready"!
     *
     * @function snapshot
     * @param    {Object} [options={}]
     *           An object of options left to the plugin author to define.
     */
    var snapshot = function snapshot(options) {
      var _this = this;

      var settings = videojs$$1.mergeOptions(defaultOptions, options);
      var player = this;
      player.ready(function () {
        onPlayerReady(_this, videojs$$1.mergeOptions(defaultOptions, options));
      });

      //crossOrgin process
      var videoTags = document.getElementsByTagName('video');
      for (var i = 0; i < videoTags.length; i++) {
        var videoTag = videoTags[i];
        videoTag.setAttribute('crossOrigin', 'Anonymous');
      }

      // create snapshoter
      player.snapshoter = new videojs$$1.SnapshoterComponent(this, {
        'options': settings
      });
      player.addChild(player.snapshoter);

      // add canvas for recording and displaying image
      player.snapshotCanvas = new SnapshotCanvasComponent(player, {
        'el': createCanvas('snapshot')
      });
      player.snapshotCanvas.hide();
      player.snapshoter.addChild(player.snapshotCanvas);

      // add camera button
      player.cameraButton = new CameraButton(player, {
        'el': createButton('camera', player.localize('Image'), 'photo-camera')
      });
      // player.cameraButton.hide();
      player.cameraButton.show();
    };

    // Register the plugin with video.js.
    registerPlugin('snapshot', snapshot);

    // Include the version number.
    //   snapshot.VERSION = VERSION;

    // export default snapshot;
    // return a function to define the module export
    return snapshot;
  });
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var Player = videojs.getComponent('Player');

QUnit.test('the environment is sane', function (assert) {
  assert.strictEqual(_typeof(Array.isArray), 'function', 'es5 exists');
  assert.strictEqual(typeof sinon === 'undefined' ? 'undefined' : _typeof(sinon), 'object', 'sinon exists');
  assert.strictEqual(typeof videojs === 'undefined' ? 'undefined' : _typeof(videojs), 'function', 'videojs exists');
  assert.strictEqual(typeof videojsSnapshot === 'undefined' ? 'undefined' : _typeof(videojsSnapshot), 'function', 'plugin is a function');
});

QUnit.module('videojs-snapshot', {
  beforeEach: function beforeEach() {

    // Mock the environment's timers because certain things - particularly
    // player readiness - are asynchronous in video.js 5. This MUST come
    // before any player is created; otherwise, timers could get created
    // with the actual timer methods!
    this.clock = sinon.useFakeTimers();

    this.fixture = document_1.getElementById('qunit-fixture');
    this.video = document_1.createElement('video');
    this.fixture.appendChild(this.video);
    this.player = videojs(this.video);
  },
  afterEach: function afterEach() {
    this.player.dispose();
    this.clock.restore();
  }
});

QUnit.test('registers itself with video.js', function (assert) {
  assert.expect(2);

  assert.strictEqual(_typeof(Player.prototype.snapshot), 'function', 'videojs-snapshot plugin was registered');

  this.player.snapshot();

  // Tick the clock forward enough to trigger the player to be "ready".
  this.clock.tick(1);

  assert.ok(this.player.hasClass('vjs-snapshot'), 'the plugin adds a class to the player');
});

}(QUnit,sinon,videojs));
